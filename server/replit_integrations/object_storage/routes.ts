import type { Express } from "express";
import { ObjectStorageService, ObjectNotFoundError } from "./objectStorage";
import { randomUUID } from "crypto";
import multer from "multer";
import path from "path";
import fs from "fs/promises";

/**
 * Register object storage routes for file uploads.
 *
 * This provides example routes for the presigned URL upload flow:
 * 1. POST /api/uploads/request-url - Get a presigned URL for uploading
 * 2. The client then uploads directly to the presigned URL
 *
 * IMPORTANT: These are example routes. Customize based on your use case:
 * - Add authentication middleware for protected uploads
 * - Add file metadata storage (save to database after upload)
 * - Add ACL policies for access control
 */
export function registerObjectStorageRoutes(app: Express): void {
  const objectStorageService = new ObjectStorageService();

  /**
   * Request a presigned URL for file upload.
   *
   * Request body (JSON):
   * {
   *   "name": "filename.jpg",
   *   "size": 12345,
   *   "contentType": "image/jpeg"
   * }
   *
   * Response:
   * {
   *   "uploadURL": "https://storage.googleapis.com/...",
   *   "objectPath": "/objects/uploads/uuid"
   * }
   *
   * IMPORTANT: The client should NOT send the file to this endpoint.
   * Send JSON metadata only, then upload the file directly to uploadURL.
   */
  app.post("/api/uploads/request-url", async (req, res) => {
    try {
      const { name, size, contentType } = req.body;

      if (!name) {
        return res.status(400).json({
          error: "Missing required field: name",
        });
      }

      // Check if we're on Replit (has sidecar endpoint)
      const isReplit = process.env.REPL_ID || false;
      
      if (isReplit) {
        // Use Replit object storage
        try {
          const uploadURL = await objectStorageService.getObjectEntityUploadURL();
          const objectPath = objectStorageService.normalizeObjectEntityPath(uploadURL);
          
          return res.json({
            uploadURL,
            objectPath,
            metadata: { name, size, contentType },
          });
        } catch (replitError) {
          console.error("Replit storage error:", replitError);
          // Fall through to direct upload
        }
      }

      // Fallback: Direct upload to server (for Render/other platforms)
      // For direct upload, we'll return the endpoint and the client will upload directly
      const uploadURL = "/api/uploads/direct-upload";
      // The actual objectPath will be generated by the server when the file is uploaded

      res.json({
        uploadURL,
        objectPath: "", // Will be set after upload
        metadata: { name, size, contentType },
        method: "POST", // Use POST for direct upload
      });
    } catch (error) {
      console.error("Error generating upload URL:", error);
      res.status(500).json({ error: "Failed to generate upload URL", details: String(error) });
    }
  });

  // Direct upload endpoint for non-Replit environments
  // Set up multer storage
  const uploadsDir = path.join(process.cwd(), "server", "public", "uploads");
  
  // Ensure uploads directory exists
  fs.mkdir(uploadsDir, { recursive: true }).catch(console.error);

  const storage = multer.diskStorage({
    destination: uploadsDir,
    filename: (req, file, cb) => {
      const uniqueId = randomUUID();
      const ext = path.extname(file.originalname);
      cb(null, `${uniqueId}${ext}`);
    },
  });

  const upload = multer({ 
    storage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  });
  const uploadSingle = upload.single("file");

  app.post("/api/uploads/direct-upload", (req, res) => {
    uploadSingle(req, res, (err) => {
      if (err) {
        console.error("Upload error:", err);
        return res.status(500).json({ error: "Upload failed", details: String(err) });
      }

      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const objectPath = `/uploads/${req.file.filename}`;
      res.json({
        objectPath,
        url: objectPath, // URL to access the file
      });
    });
  });

  /**
   * Serve uploaded objects.
   *
   * GET /objects/:objectPath(*)
   *
   * This serves files from object storage. For public files, no auth needed.
   * For protected files, add authentication middleware and ACL checks.
   */
  app.get("/objects/:objectPath(*)", async (req, res) => {
    try {
      const objectFile = await objectStorageService.getObjectEntityFile(req.path);
      await objectStorageService.downloadObject(objectFile, res);
    } catch (error) {
      console.error("Error serving object:", error);
      if (error instanceof ObjectNotFoundError) {
        return res.status(404).json({ error: "Object not found" });
      }
      return res.status(500).json({ error: "Failed to serve object" });
    }
  });
}

